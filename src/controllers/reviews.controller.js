import { Op } from 'sequelize';
import { Review, ReviewCategory, ManagerResponse, Property } from '../db/index.js';
import { buildReviewFilters } from '../utils/buildFilters.js';
import { z } from 'zod';

/**
 * Controller: list
 * Returns a paginated list of reviews with optional filters:
 *  - category/scoreGte filter
 *  - sorting
 *  - related property and manager response info
 */
export async function list(req, res, next) {
    try {
        // Pagination
        const page = Math.max(1, Number(req.query.page || 1));
        const pageSize = Math.min(100, Number(req.query.pageSize || 20));

        // Build where clause from query params (utility fn)
        const where = buildReviewFilters(req.query);

        // Relations to include
        const include = [
            { model: ReviewCategory, as: 'categories', required: false },
            { model: ManagerResponse, as: 'manager_response', required: false, attributes: ['responded_at'] },
            { model: Property, attributes: ['id', 'name'] }
        ];

        // If category filter requested, enforce join + optional score filter
        if (req.query.category) {
            include[0].required = true;
            include[0].where = {
                category: req.query.category,
                ...(req.query.scoreGte
                    ? { score: { [Op.gte]: Number(req.query.scoreGte) } }
                    : {})
            };
        }

        // Sorting (default: newest first)
        const sort = req.query.sort || '-submitted_at';
        const order = sort.startsWith('-')
            ? [[sort.slice(1), 'DESC']]
            : [[sort, 'ASC']];

        // Query with pagination
        const { rows, count } = await Review.findAndCountAll({
            where, include, order,
            offset: (page - 1) * pageSize,
            limit: pageSize
        });

        // Shape response
        res.json({
            page, pageSize, total: count,
            items: rows.map(r => ({
                id: r.id,
                property_id: r.property_id,
                source: r.source,
                type: r.type,
                status: r.status,
                rating: r.rating ? Number(r.rating) : null,
                comment: r.comment,
                channel: r.channel,
                submitted_at: r.submitted_at,
                guest_name: r.guest_name,
                approved_for_website: r.approved_for_website,
                categories: r.categories?.map(c => ({
                    category: c.category,
                    score: Number(c.score)
                })) || [],
                manager_response: r.manager_response
                    ? { has_response: true, responded_at: r.manager_response.responded_at }
                    : { has_response: false }
            }))
        });
    } catch (err) {
        next(err);
    }
}

// Schema for PATCH validation: ensures at least one field is provided
const PatchSchema = z.object({
    approved_for_website: z.boolean().optional(),
    status: z.enum(['published', 'pending', 'hidden', 'archived']).optional()
}).refine((x) => Object.keys(x).length > 0, { message: 'No changes provided' });

/**
 * Controller: patch
 * Allows partial update of a review (approval/status).
 */
export async function patch(req, res, next) {
    try {
        const data = PatchSchema.parse(req.body); // Validate input
        const r = await Review.findByPk(req.params.id);
        if (!r) {
            return res.status(404).json({
                error: { code: 'not_found', message: 'Review not found' }
            });
        }
        await r.update(data); // Apply changes
        res.json(r);
    } catch (err) {
        next(err);
    }
}

// Schema for creating a manager response
const RespSchema = z.object({ body: z.string().min(1) });

/**
 * Controller: createResponse
 * Creates a manager response attached to a review.
 */
export async function createResponse(req, res, next) {
    try {
        const { body } = RespSchema.parse(req.body); // Validate input
        const r = await Review.findByPk(req.params.id);
        if (!r) {
            return res.status(404).json({
                error: { code: 'not_found', message: 'Review not found' }
            });
        }

        // Association helper generated by Sequelize (createManager_response)
        const mr = await r.createManager_response({ body });

        res.status(201).json({
            id: mr.id,
            review_id: r.id,
            responded_at: mr.responded_at
        });
    } catch (err) {
        next(err);
    }
}
